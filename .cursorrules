# Bifrost Options Trading Strategy Analyzer - Cursor Rules

## Project Overview

Bifrost is a professional options trading strategy analyzer system that integrates with Interactive Brokers to provide:
- Real-time option chain data from IB Gateway
- Strategy analysis (Covered Call, Iron Condor, etc.)
- Historical option tracking with PostgreSQL + TimescaleDB
- ML-based strategy optimization
- Multi-machine distributed deployment

## Architecture Principles

### Technology Stack
- **Backend API**: FastAPI (Port 8000) - High-performance trading API, real-time data, async operations
- **Admin/Management**: Django (Port 8001) - Admin interface, data management, migrations
- **Shared Database**: PostgreSQL + TimescaleDB (both frameworks access same database)
- **Portal UI**: Vue.js 3 + Skote Theme Reference (Web-Server) - Production trading interface
- **Monitoring**: Streamlit (Dev PC) - System monitoring and analytics dashboards (app_monitor/)
- **Data Management**: Django Admin (APP-SERVER) - CRUD operations

### Multi-Machine Deployment
- **Dev PC (10.0.0.90)**: Development, SSH management, Streamlit monitoring (app_monitor/)
- **APP-SERVER (10.0.0.80)**: FastAPI, Django, PostgreSQL, IB Gateway
- **Web-Server (10.0.0.75)**: Nginx, Vue.js portal UI
- **RTX4090-Server (10.0.0.60)**: ML/AI services with GPU

## Project Structure Rules

### FastAPI Code Organization (app_api/)
- **app_api/api/**: FastAPI application, routes, middleware (FastAPI only)
  - Use `app_api/api/routes/` for route handlers (one file per domain)
  - Use `app_api/api/middleware/` for custom middleware
  - Main app in `app_api/api/main.py`
- **app_api/database/**: Database layer (FastAPI only - SQLAlchemy ORM)
  - `schemas.py`: Pydantic models (API request/response)
  - `models.py`: SQLAlchemy ORM models (mirror Django models)
  - `connection.py`: Database connection configuration
  - `repositories/`: Data access layer (SQLAlchemy)

### Shared Business Logic (src/)
- **src/core/**: Core business logic (CAN BE SHARED with Django and Streamlit/monitoring)
  - IB connector (`src/core/connector/ib.py`)
  - Options chain fetcher (`src/core/data/options_chain.py`)
  - Exchange manager (`src/core/data/exchange.py`)
  - Config (`src/config.py`)
- **src/analyzer/**: Analysis engines (CAN BE SHARED)
  - Analyzer, filter, risk calculator
- **src/strategies/**: Strategy implementations (CAN BE SHARED)
  - base_strategy, covered_call, iron_condor
- **src/utils/**: Utility functions (CAN BE SHARED)
  - logger, validators, database_constants
- **src/backtesting/**: Backtesting engines (CAN BE SHARED)
  - backtester, vectorbt_engine

### Django Code Organization (app_admin/)
- **app_admin/django_config/**: Django project settings
- **app_admin/apps/**: Django apps
  - `options/`: Options data models & admin (Django ORM only)
  - `strategies/`: Strategy history models & admin (Django ORM only)
  - `data_collection/`: Data collection management commands
- Django manages database migrations (source of truth)
- SQLAlchemy models must mirror Django models
- **CAN IMPORT from**: `src/core/`, `src/analyzer/`, `src/strategies/`, `src/utils/`, `src/backtesting/`, `services/`
- **CANNOT IMPORT from**: `app_api/database/` (use Django ORM instead), `app_api/api/` (FastAPI only)

### Background Services (services/)
- **services/**: Background services (CAN BE SHARED by FastAPI, Django, Streamlit/monitoring)
  - `data_collector.py`: Periodic option chain collection (Celery)
  - `ib_data_collector.py`: Comprehensive IB data collection service
  - `history_service.py`: Historical data management
  - `tasks.py`: Celery task definitions
  - `scheduler.py`: Task scheduling
- Services can use shared business logic from `src/core/`, `src/analyzer/`, etc.
- Services typically use SQLAlchemy for database operations (FastAPI-style)

### Portal UI (app_portal/)
- **app_portal/**: Vue.js 3 portal UI application
  - Uses Skote Nodejs v4.2.0 theme as **design reference only**
  - Theme located in `ref_themes/skote_nodejs_v4.2.0/` (excluded from git)
  - Build custom Vue.js components following Skote's design patterns
  - Convert EJS patterns to Vue.js patterns
  - Reference SCSS styling from theme

### Theme Reference (ref_themes/)
- **ref_themes/skote_nodejs_v4.2.0/**: Purchased Skote theme (EXCLUDED from git)
  - **Type**: Node.js/Express.js backend template with EJS views
  - **Purpose**: Design reference template for building Vue.js portal UI
  - **Usage**: Reference only - convert EJS patterns to Vue.js
  - **Launch**: Use `./scripts/portal_ui/launch_skote.sh admin` to view theme in browser
  - **Important**: This is NOT a Vue.js template - use as design reference only

## Import Conventions

### FastAPI Code (app_api/)
- Use **absolute imports** for shared code:
  - `from src.core.config import config`
  - `from src.analyzer.analyzer import get_analyzer`
  - `from app_api.database.schemas import OptionsChain`
- Use **relative imports** within app_api:
  - `from .routes import health`
  - `from ..database.connection import get_db`

### Django Code (app_admin/)
- Use Django's standard import patterns
- Import Django models: `from apps.options.models import OptionSnapshot`

### Cross-Framework Imports

**Database ORM Layer (SEPARATE):**
- `app_api/database/` - FastAPI only (SQLAlchemy ORM)
- `app_admin/apps/*/models.py` - Django only (Django ORM)
- **DO NOT** mix database ORM code between frameworks

**Shared Business Logic (CAN BE SHARED):**
- `src/core/` - Can be imported by FastAPI, Django, and Streamlit/monitoring
  - IB connector (`src/core/connector/ib.py`)
  - Options chain fetcher (`src/core/data/options_chain.py`)
  - Exchange manager (`src/core/data/exchange.py`)
  - Config (`src/config.py`)
- `src/analyzer/` - Can be shared (analysis engines)
- `src/strategies/` - Can be shared (strategy implementations)
- `src/utils/` - Can be shared (utilities, logger)
- `src/backtesting/` - Can be shared (backtesting engines)
- `services/` - Can be shared (background services)

**Shared Utilities:**
- `src/utils/` - Shared utility functions and constants
  - `database_constants.py` - Database table names and constants (shared between FastAPI and Django)
  - `logger.py` - Logging utilities
  - `validators.py` - Validation utilities
  - `pricing.py` - Pricing utilities

**Summary:**
- ✅ Database ORM: Keep separate (SQLAlchemy vs Django ORM)
- ✅ Business logic: Can be shared (IB connector, analyzers, strategies)
- ✅ Services: Can be shared (background tasks)
- ✅ Both frameworks access same database via their respective ORMs

## Code Style & Standards

### Python
- Follow PEP 8 style guide
- Use type hints for all function parameters and return types
- Use async/await for FastAPI endpoints and IB operations
- Use Pydantic models for API request/response validation
- Use docstrings for all classes and functions

### FastAPI Best Practices
- Split routes into separate files by domain (health, options, strategies, history)
- Use dependency injection for shared resources (database sessions, connectors)
- Use Pydantic models for request/response validation
- Return proper HTTP status codes
- Include error handling with meaningful error messages

### Django Best Practices
- Use Django ORM for all database operations
- Create migrations for all model changes
- Use Django admin for data management interfaces
- Use management commands for background tasks

### Portal UI (Vue.js) Best Practices
- Reference Skote theme in `ref_themes/skote_nodejs_v4.2.0/` for design patterns
- Convert EJS templates to Vue.js components
- Follow Skote's SCSS styling patterns
- Build custom trading components in `app_portal/src/components/trading/`
- Use Vue 3 Composition API
- Integrate with FastAPI backend via API client

## Database Rules

### Schema Management - CRITICAL WORKFLOW

**⭐ SINGLE SOURCE OF TRUTH: `app_admin/apps/*/models.py` (Django Models)**

**ALL database schema changes MUST follow this exact workflow:**

```
1. Update Django models (app_admin/apps/*/models.py) ⭐ SINGLE SOURCE OF TRUTH
   ↓
2. Generate Django migrations (python manage.py makemigrations)
   ↓
3. Update SQLAlchemy models (app_api/database/models.py) to match Django models
   ↓
4. Update scripts/database/schema_*.sql to match Django models
   ↓
5. Run refresh_schema.py to verify all are in sync
```

**When making ANY database schema change:**

1. **ALWAYS start with Django models** (`app_admin/apps/*/models.py`)
   - This is the authoritative schema definition
   - All changes start here
   - Use proper Django field types and constraints
   - Django models are the single source of truth

2. **Generate Django migrations:**
   ```bash
   cd app_admin
   python manage.py makemigrations
   python manage.py migrate
   ```
   - Review generated migrations to ensure they match your intended changes
   - Migrations track all schema changes automatically

3. **Update SQLAlchemy models** in `app_api/database/models.py` to match Django models exactly
   - Must mirror Django models field-by-field
   - Match field types, constraints, and indexes
   - Keep `__tablename__` matching Django's `db_table`
   - Update docstrings to reference Django model

4. **Update schema.sql** in `scripts/database/schema_*.sql` to match Django models
   - Use `IF NOT EXISTS` / `IF EXISTS` for idempotent operations
   - Document changes in version tracking section (optional, for reference)
   - Include comments for new tables/columns

5. **Verify synchronization:**
   ```bash
   ./scripts/database/refresh_schema.sh
   ```
   - Compares Django models, SQLAlchemy models, and schema files
   - All three should match
   - If discrepancies found, fix starting from Django models (source of truth)

**Important Rules:**
- ✅ **ALWAYS** update Django models first (single source of truth)
- ✅ **ALWAYS** generate and review Django migrations
- ✅ **ALWAYS** update SQLAlchemy models to match Django models
- ✅ **ALWAYS** update schema.sql to match Django models
- ✅ **ALWAYS** run refresh_schema.sh to verify all three are in sync
- ❌ **NEVER** modify SQLAlchemy models or schema.sql without updating Django models first
- ❌ **NEVER** skip the verification step

**Reference Documentation:**
- Complete guide: `docs/database/database.md` (Schema Management)
- Django models: `app_admin/apps/*/models.py` (Single Source of Truth)

### Database Access
- FastAPI: Use SQLAlchemy with async engine for database access
- Django: Use Django ORM (sync) for database access
- Both frameworks access the same PostgreSQL database
- Use connection pooling appropriately for each framework
- Use TimescaleDB hypertables for time-series data (option_snapshots)

## IB Gateway Integration

### Connection Management
- Single IB Gateway instance on APP-SERVER (port 7497/7496)
- Use connection pooling with multiple client IDs:
  - Client ID 1: FastAPI real-time requests
  - Client ID 2: Data collector service
  - Client ID 3: Background analysis jobs
- Implement auto-reconnect logic
- Use async/await for all IB operations

### Code Location
- IB connector: `src/core/connector/ib.py`
- Options chain fetcher: `src/core/data/options_chain.py`
- Use caching to reduce IB API calls

## File Naming Conventions

- Python files: `snake_case.py`
- Route files: `snake_case.py` (e.g., `options.py`, `strategies.py`)
- Model files: `models.py` (Django), `schemas.py` (Pydantic), `models.py` (SQLAlchemy)
- Test files: `test_*.py`
- Script files: `snake_case.sh` or `snake_case.py`

## Testing

- Unit tests: `tests/unit/`
- Integration tests: `tests/integration/`
- E2E tests: `tests/e2e/`
- Test FastAPI endpoints
- Test strategy calculations
- Test database operations

## Documentation

- API documentation: Auto-generated by FastAPI at `/docs`
- Project plan: `docs/PROJECT_PLAN.md`
- API development guide: `docs/api/API_DEVELOPMENT_GUIDE.md`
- Code comments: Explain complex logic, not obvious code
- Docstrings: Required for all public functions and classes

## Deployment

### Service Configuration
- FastAPI: Systemd service on APP-SERVER (port 8000)
- Django: Systemd service on APP-SERVER (port 8001)
- Use Gunicorn + Uvicorn workers for FastAPI
- Use Gunicorn for Django
- Nginx reverse proxy on Web-Server

### Environment Variables
- Use `.env` files for configuration
- Never commit secrets to git
- Use environment-specific configurations

## Open Source Libraries

### Phase 1 (Essential)
- Plotly: Interactive charts
- Celery + Redis: Background jobs
- py_vollib: Options pricing
- APScheduler: Simple scheduling

### Phase 2 (Short-term)
- VectorBT: Fast backtesting
- QuantLib: Advanced pricing models
- TA-Lib: Technical indicators

## Error Handling

- Use proper exception handling
- Log errors with context
- Return meaningful error messages to API clients
- Use HTTP status codes appropriately (400, 404, 500, etc.)
- Never expose internal errors to clients in production

## Performance Considerations

- Use async/await for I/O operations
- Implement caching for frequently accessed data
- Use connection pooling for database and IB connections
- Optimize database queries
- Consider caching option chains

## Security

- Never hardcode credentials
- Use environment variables for secrets
- Implement API authentication (JWT tokens - future)
- Validate all user inputs
- Use parameterized queries for database operations

## When Making Changes

### General Changes
1. **Follow the project structure** - Don't create files in wrong locations
2. **Update imports** - Use absolute imports for shared code, relative within packages
3. **Maintain separation** - FastAPI and Django should not import from each other
4. **Update tests** - Add tests for new functionality
5. **Update documentation** - Update relevant docs when adding features
6. **Check linter** - Ensure no linter errors before committing
7. **Test imports** - Verify all imports work correctly

### Database Schema Changes (CRITICAL)
**MUST follow this workflow in order:**

1. **Update Django models** (`app_admin/apps/*/models.py`) ⭐ (SINGLE SOURCE OF TRUTH)
   - Add/modify table definitions
   - Add indexes, constraints in Meta class
   - Use proper Django field types
   - Django models are the authoritative source

2. **Generate Django migrations**
   ```bash
   cd app_admin
   python manage.py makemigrations
   python manage.py migrate
   ```
   - Review generated migrations
   - Migrations track all schema changes

3. **Update SQLAlchemy models** (`app_api/database/models.py`)
   - Mirror Django models exactly
   - Match field types, constraints, indexes
   - Keep `__tablename__` matching Django's `db_table`

4. **Update schema.sql** (`scripts/database/schema_*.sql`)
   - Match Django models
   - Use idempotent SQL (`IF NOT EXISTS`, `IF EXISTS`)
   - Document changes in version tracking section (optional)

5. **Verify synchronization**
   ```bash
   ./scripts/database/refresh_schema.sh
   ```
   - Compares Django models, SQLAlchemy models, and schema files
   - All three should match
   - Fix any discrepancies starting from Django models

**See `docs/database/database.md` for detailed examples and best practices.**

### Portal UI Development
1. **Reference Skote Theme**: Study `ref_themes/skote_nodejs_v4.2.0/Admin/views/` for design patterns
2. **Convert EJS to Vue.js**: Transform EJS templates to Vue.js components
3. **Reference SCSS**: Study `ref_themes/skote_nodejs_v4.2.0/Admin/src/assets/scss/` for styling
4. **Build Custom Components**: Create trading-specific components in `app_portal/src/components/trading/`
5. **Launch Theme**: Use `./scripts/portal_ui/launch_skote.sh admin` to view theme in browser for reference

## Common Patterns

### FastAPI Route Pattern
```python
from fastapi import APIRouter
from app_api.database.schemas import ResponseModel
from src.core.something import get_something

router = APIRouter()

@router.get("/api/endpoint", response_model=ResponseModel)
async def endpoint():
    # Implementation
    pass
```

### Database Access Pattern
```python
# FastAPI (SQLAlchemy)
from app_api.database.connection import AsyncSessionLocal
async with AsyncSessionLocal() as session:
    # Query database
    pass

# Django (Django ORM)
from apps.options.models import OptionSnapshot
OptionSnapshot.objects.filter(...)
```

### IB Connection Pattern
```python
from src.core.connector.ib import get_connector
connector = await get_connector()
# Use connector
```

### Portal UI Component Pattern (Vue.js)
```vue
<template>
  <!-- Reference Skote EJS templates for HTML structure -->
  <div class="card">
    <!-- Custom trading component -->
  </div>
</template>

<script setup>
// Reference Skote JS patterns, adapt for Vue.js
import { useOptionsStore } from '@/store/options'
</script>

<style scoped lang="scss">
// Reference Skote SCSS for styling
@import '@/styles/variables'; // Skote-inspired variables
</style>
```

## Prohibited Practices

- ❌ Don't mix FastAPI and Django imports
- ❌ Don't create circular dependencies
- ❌ Don't use relative imports for shared code (use absolute)
- ❌ Don't modify database schema without following the canonical schema workflow
- ❌ Don't modify Django or SQLAlchemy models without updating schema.sql first
- ❌ Don't commit secrets or credentials
- ❌ Don't create files outside the defined structure
- ❌ Don't bypass the ORM for database access (use repositories)
- ❌ Don't copy theme files directly - use as reference only
- ❌ Don't commit theme source code to git

## Project Goals

1. **Real-time Trading**: Provide fast, reliable real-time option chain data
2. **Strategy Analysis**: Analyze multiple option strategies with accurate calculations
3. **Historical Tracking**: Track option history for pattern analysis
4. **ML Optimization**: Use ML for strategy recommendations
5. **Scalability**: Design for horizontal scaling when needed
6. **Maintainability**: Clean, organized code structure
7. **Performance**: Optimize for low latency trading operations

## Key Design Decisions

1. **Hybrid FastAPI + Django**: Use each framework for its strengths
2. **Shared Database**: Both frameworks access same PostgreSQL database
3. **Co-located Services**: API, DB, and IB Gateway on APP-SERVER for low latency
4. **Separation of Concerns**: Clear boundaries between components
5. **Async-First**: Use async/await for all I/O operations in FastAPI
6. **Theme Reference**: Use Skote theme as design template, not source code

## Theme Reference Guidelines

### Using Skote Theme as Template

**Location**: `ref_themes/skote_nodejs_v4.2.0/` (excluded from git)

**Important Notes**:
- ⚠️ This is a **Node.js/Express.js template** (EJS views), NOT Vue.js
- ✅ Use as **design reference only** - convert EJS patterns to Vue.js
- ✅ Reference SCSS styling from `Admin/src/assets/scss/`
- ✅ Study layout structure from `Admin/views/layouts/` and `Admin/views/partials/`
- ✅ Launch theme to view in browser: `./scripts/portal_ui/launch_skote.sh admin`

**Conversion Approach**:
1. Study EJS templates in `Admin/views/`
2. Convert EJS patterns to Vue.js components
3. Reference SCSS for styling
4. Build custom trading components in `app_portal/`
5. Integrate with FastAPI backend

**Example Conversion**:
- EJS: `<%- include('partials/sidebar') %>` → Vue: `<Sidebar />`
- EJS: `<div class="card">` → Vue: Same HTML structure, Vue.js logic
- SCSS: Reference color variables, spacing, typography

**When Building Portal UI**:
- Always reference `ref_themes/skote_nodejs_v4.2.0/` for design patterns
- Convert EJS to Vue.js, don't copy directly
- Follow Skote's design system and styling
- Build custom components for trading functionality

## When in Doubt

- Refer to `docs/PROJECT_PLAN.md` for architecture decisions
- Follow existing code patterns in the codebase
- Use absolute imports for shared code
- Keep FastAPI and Django code separate
- Test imports and functionality after changes
- Reference Skote theme for portal UI design patterns
- See `ref_themes/THEME_STRUCTURE.md` for theme analysis
- See `app_portal/THEME_INTEGRATION.md` for integration guide
